# Task 007: Internal Oversampling (2× Real-Time, 4× Offline)

## Objective

Implement internal oversampling to reduce aliasing artifacts generated by the nonlinear stages (waveshaper, dynamic bias). Oversampling is transparent to the user — no exposed controls.

```
Input → [Upsample] → DSP chain → [Downsample] → Mix → Output
```

---

## Prerequisites

- Task 006 completed (full DSP chain working without oversampling)

---

## Design Rationale

### Why Oversampling?

Nonlinear processing (tanh, dynamic bias) generates new harmonics. Some of these harmonics exceed the Nyquist frequency and fold back as **aliasing** — inharmonic, unmusical distortion.

| Without Oversampling | With 2× | With 4× |
|---------------------|---------|---------|
| Aliasing audible on bright material | Greatly reduced | Negligible |
| ✗ | Good for real-time | Good for offline |

### Why Internal (Not User-Exposed)?

From the PRD:
> "Internal oversampling: 2× real-time; 4× offline render. No technical decisions required from the user."

- Users shouldn't need to understand oversampling
- Automatic switching based on context (real-time vs bounce)
- Aligns with GRAIN's "safe" philosophy

### Why 2× / 4× (Not Higher)?

| Factor | CPU Cost | Aliasing Reduction | Latency |
|--------|----------|-------------------|---------|
| 1× | None | None | 0 |
| **2×** | ~2× | Good | Minimal |
| **4×** | ~4× | Excellent | Moderate |
| 8× | ~8× | Near-perfect | High |

2× is the sweet spot for real-time (minimal CPU, good quality).
4× for offline (CPU doesn't matter, maximum quality).

---

## Architecture

### JUCE's Built-in Oversampling

JUCE provides `juce::dsp::Oversampling<float>` which handles:
- Upsampling with anti-aliasing filter
- Downsampling with anti-imaging filter
- Latency reporting
- Multiple quality modes

### Integration Pattern

```cpp
// The key insight: oversampling wraps the ENTIRE DSP chain
// Dry signal is kept at original sample rate for mix

Input → [Copy dry] → [Upsample 2×/4×] → Full DSP chain at higher rate → [Downsample] → Mix (with dry) → Gain → Output
```

**Important:** Mix and Output Gain operate at the original sample rate (no need to oversample linear operations).

### Implementation (in `PluginProcessor`)

```cpp
// In PluginProcessor.h
#include <juce_dsp/juce_dsp.h>

class GrainProcessor : public juce::AudioProcessor
{
    // ...
    
    std::unique_ptr<juce::dsp::Oversampling<float>> oversampling;
    
    // DSP modules prepared at oversampled rate
    GrainDSP::RMSDetector rmsDetector;
    GrainDSP::SpectralFocus spectralFocus;
    
    // Track current oversampling factor
    int currentOversamplingOrder = 1;  // 2^1 = 2×
};
```

```cpp
// In PluginProcessor.cpp

void prepareToPlay(double sampleRate, int samplesPerBlock)
{
    // Determine oversampling factor
    // 2^1 = 2× for real-time, 2^2 = 4× for offline
    currentOversamplingOrder = isNonRealtime() ? 2 : 1;
    
    oversampling = std::make_unique<juce::dsp::Oversampling<float>>(
        getTotalNumInputChannels(),     // Number of channels
        currentOversamplingOrder,        // Order: 2^order
        juce::dsp::Oversampling<float>::filterHalfBandPolyphaseIIR,
        true                             // Maximum quality
    );
    
    oversampling->initProcessing(static_cast<size_t>(samplesPerBlock));
    
    // Prepare DSP modules at OVERSAMPLED rate
    double oversampledRate = sampleRate * oversampling->getOversamplingFactor();
    
    rmsDetector.prepare(
        static_cast<float>(oversampledRate),
        GrainDSP::Constants::kRMSAttackMs,
        GrainDSP::Constants::kRMSReleaseMs
    );
    
    spectralFocus.prepare(
        static_cast<float>(oversampledRate),
        static_cast<GrainDSP::FocusMode>(static_cast<int>(*focusParam))
    );
    
    // Smoothed values at OVERSAMPLED rate
    driveSmoothed.reset(oversampledRate, 0.02);
    biasSmoothed.reset(oversampledRate, 0.02);
    warmthSmoothed.reset(oversampledRate, 0.02);
    
    // Mix and gain at ORIGINAL rate (applied after downsampling)
    mixSmoothed.reset(sampleRate, 0.02);
    gainSmoothed.reset(sampleRate, 0.02);
}
```

```cpp
void processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ScopedNoDenormals noDenormals;
    
    // --- 1. Save dry signal (at original rate) ---
    juce::AudioBuffer<float> dryBuffer;
    dryBuffer.makeCopyOf(buffer);
    
    // --- 2. Update targets ---
    driveSmoothed.setTargetValue(*driveParam);
    biasSmoothed.setTargetValue(*biasParam);
    warmthSmoothed.setTargetValue(*warmthParam);
    
    bool bypass = *bypassParam > 0.5f;
    float targetMix = bypass ? 0.0f : static_cast<float>(*mixParam);
    mixSmoothed.setTargetValue(targetMix);
    gainSmoothed.setTargetValue(juce::Decibels::decibelsToGain(*outputParam));
    
    // --- 3. Upsample ---
    juce::dsp::AudioBlock<float> block(buffer);
    auto oversampledBlock = oversampling->processSamplesUp(block);
    
    // --- 4. Process DSP at oversampled rate ---
    int numOversampledSamples = static_cast<int>(oversampledBlock.getNumSamples());
    int numChannels = static_cast<int>(oversampledBlock.getNumChannels());
    
    for (int sample = 0; sample < numOversampledSamples; ++sample)
    {
        float drive = driveSmoothed.getNextValue();
        float biasAmount = biasSmoothed.getNextValue();
        float warmth = warmthSmoothed.getNextValue();
        
        // Linked stereo RMS: average of both channels
        float monoInput = 0.0f;
        for (int ch = 0; ch < numChannels; ++ch)
        {
            monoInput += oversampledBlock.getSample(ch, sample);
        }
        monoInput /= static_cast<float>(numChannels);
        float rmsLevel = rmsDetector.process(monoInput);
        
        for (int channel = 0; channel < numChannels; ++channel)
        {
            float input = oversampledBlock.getSample(channel, sample);
            
            // Dynamic bias
            float biased = GrainDSP::applyDynamicBias(input, rmsLevel, biasAmount);
            
            // Waveshaper
            float shaped = GrainDSP::applyWaveshaper(biased, drive);
            
            // Warmth
            float warmed = GrainDSP::applyWarmth(shaped, warmth, 0.0f);
            
            // Spectral focus
            float focused = spectralFocus.process(warmed, channel);
            
            oversampledBlock.setSample(channel, sample, focused);
        }
    }
    
    // --- 5. Downsample ---
    oversampling->processSamplesDown(block);
    
    // --- 6. Mix + Gain at original rate ---
    for (int channel = 0; channel < buffer.getNumChannels(); ++channel)
    {
        auto* wetData = buffer.getWritePointer(channel);
        auto* dryData = dryBuffer.getReadPointer(channel);
        
        for (int sample = 0; sample < buffer.getNumSamples(); ++sample)
        {
            float mix = mixSmoothed.getNextValue();
            float gain = gainSmoothed.getNextValue();
            
            float mixed = GrainDSP::applyMix(dryData[sample], wetData[sample], mix);
            wetData[sample] = GrainDSP::applyGain(mixed, gain);
        }
    }
}
```

---

## Latency Reporting

Oversampling introduces latency from the anti-aliasing filters. JUCE handles this, but we must report it to the host:

```cpp
// In PluginProcessor.cpp
int getLatencySamples() const
{
    if (oversampling != nullptr)
        return static_cast<int>(oversampling->getLatencyInSamples());
    
    return 0;
}

// Call after creating oversampling in prepareToPlay:
setLatencySamples(static_cast<int>(oversampling->getLatencyInSamples()));
```

**Note from PRD:** "Latency: 0 samples in real-time" — JUCE's polyphase IIR has minimal latency (~5-8 samples at 2×). This is negligible but should be reported honestly. The host will compensate automatically.

---

## JUCE Module Dependency

This task requires the `juce_dsp` module. Verify it's included:

1. Open `GRAIN.jucer` in Projucer
2. Check modules list for `juce_dsp`
3. If missing: click `+` → add `juce_dsp`
4. Save and re-export to Xcode

---

## Real-Time vs Offline Detection

```cpp
// JUCE provides isNonRealtime() in AudioProcessor
bool isOffline = isNonRealtime();

// This is set by the host:
// - DAW playback → false (real-time)
// - DAW bounce/render → true (offline)
// - Standalone app → false (always real-time)
```

### Handling Sample Rate Changes

If the host changes between real-time and offline, `prepareToPlay` is called again. The oversampling factor will be recalculated automatically.

---

## Unit Tests

Add to `Source/Tests/DSPTests.cpp`:

```cpp
void runOversamplingTests()
{
    beginTest("Oversampling: silence in produces silence out");
    {
        // Create oversampler (2× = order 1)
        juce::dsp::Oversampling<float> os(1, 1,
            juce::dsp::Oversampling<float>::filterHalfBandPolyphaseIIR, true);
        
        constexpr int blockSize = 512;
        os.initProcessing(blockSize);
        
        // Create silent buffer
        juce::AudioBuffer<float> buffer(1, blockSize);
        buffer.clear();
        
        juce::dsp::AudioBlock<float> block(buffer);
        
        // Upsample
        auto upBlock = os.processSamplesUp(block);
        
        // Verify upsampled block is silent
        for (int i = 0; i < static_cast<int>(upBlock.getNumSamples()); ++i)
        {
            expectWithinAbsoluteError(upBlock.getSample(0, i), 0.0f, TestConstants::TOLERANCE);
        }
        
        // Downsample
        os.processSamplesDown(block);
        
        // Verify output is silent
        for (int i = 0; i < blockSize; ++i)
        {
            expectWithinAbsoluteError(buffer.getSample(0, i), 0.0f, TestConstants::TOLERANCE);
        }
    }

    beginTest("Oversampling: upsampled block has correct size");
    {
        // 2× oversampling
        juce::dsp::Oversampling<float> os2x(1, 1,
            juce::dsp::Oversampling<float>::filterHalfBandPolyphaseIIR, true);
        
        constexpr int blockSize = 256;
        os2x.initProcessing(blockSize);
        
        juce::AudioBuffer<float> buffer(1, blockSize);
        buffer.clear();
        
        juce::dsp::AudioBlock<float> block(buffer);
        auto upBlock = os2x.processSamplesUp(block);
        
        // 2× should double the samples
        expectEquals(static_cast<int>(upBlock.getNumSamples()), blockSize * 2);
        
        os2x.processSamplesDown(block);
    }

    beginTest("Oversampling: 4x upsampled block has correct size");
    {
        // 4× oversampling (order 2)
        juce::dsp::Oversampling<float> os4x(1, 2,
            juce::dsp::Oversampling<float>::filterHalfBandPolyphaseIIR, true);
        
        constexpr int blockSize = 256;
        os4x.initProcessing(blockSize);
        
        juce::AudioBuffer<float> buffer(1, blockSize);
        buffer.clear();
        
        juce::dsp::AudioBlock<float> block(buffer);
        auto upBlock = os4x.processSamplesUp(block);
        
        // 4× should quadruple the samples
        expectEquals(static_cast<int>(upBlock.getNumSamples()), blockSize * 4);
        
        os4x.processSamplesDown(block);
    }

    beginTest("Oversampling: latency is reported correctly");
    {
        juce::dsp::Oversampling<float> os(1, 1,
            juce::dsp::Oversampling<float>::filterHalfBandPolyphaseIIR, true);
        
        os.initProcessing(512);
        
        float latency = os.getLatencyInSamples();
        
        // Polyphase IIR should have some latency
        expect(latency >= 0.0f);
        expect(latency < 50.0f);  // Reasonable upper bound
    }

    beginTest("Oversampling: signal passes through with minimal change");
    {
        juce::dsp::Oversampling<float> os(1, 1,
            juce::dsp::Oversampling<float>::filterHalfBandPolyphaseIIR, true);
        
        constexpr int blockSize = 512;
        os.initProcessing(blockSize);
        
        // Generate low frequency sine (well below Nyquist)
        juce::AudioBuffer<float> buffer(1, blockSize);
        float sampleRate = 44100.0f;
        float freq = 440.0f;
        
        for (int i = 0; i < blockSize; ++i)
        {
            buffer.setSample(0, i,
                0.5f * std::sin(2.0f * juce::MathConstants<float>::pi * freq * i / sampleRate));
        }
        
        // Process multiple blocks to get past initial transient
        for (int rep = 0; rep < 10; ++rep)
        {
            // Regenerate input each time
            for (int i = 0; i < blockSize; ++i)
            {
                buffer.setSample(0, i,
                    0.5f * std::sin(2.0f * juce::MathConstants<float>::pi * freq *
                        (i + rep * blockSize) / sampleRate));
            }
            
            juce::dsp::AudioBlock<float> block(buffer);
            auto upBlock = os.processSamplesUp(block);
            // No processing — just pass through
            os.processSamplesDown(block);
        }
        
        // After settling, signal should be close to original
        // Check RMS is reasonable (not zero, not wildly different)
        float rms = 0.0f;
        for (int i = 0; i < blockSize; ++i)
        {
            float s = buffer.getSample(0, i);
            rms += s * s;
        }
        rms = std::sqrt(rms / blockSize);
        
        // Original RMS of 0.5 sine ≈ 0.354
        // After oversampling round-trip, should be close
        expect(rms > 0.2f);
        expect(rms < 0.5f);
    }
}
```

Don't forget to call `runOversamplingTests()` from `runTest()`.

---

## Files to Create/Modify

| File | Action |
|------|--------|
| `GRAIN.jucer` | Verify `juce_dsp` module is included |
| `Source/PluginProcessor.h` | Add oversampling member, dry buffer |
| `Source/PluginProcessor.cpp` | Restructure processBlock with up/downsample |
| `Source/Tests/DSPTests.cpp` | Add oversampling tests |

---

## Signal Flow After This Task

```
Input → [Copy dry] → [Upsample 2×/4×]
                            ↓
                      RMS Detector → envelope
                            ↓            ↓
                      Dynamic Bias ←─────┘
                            ↓
                      Waveshaper (tanh)
                            ↓
                         Warmth
                            ↓
                      Spectral Focus
                            ↓
                      [Downsample]
                            ↓
              Mix (with dry copy) → Gain → Output
```

---

## Acceptance Criteria

### Functional
- [ ] Oversampling compiles without errors
- [ ] 2× active in real-time playback
- [ ] 4× active during offline bounce
- [ ] Silence produces silence
- [ ] Signal passes through with minimal degradation
- [ ] Upsampled block has correct size (2× or 4× samples)
- [ ] Latency reported to host

### Quality
- [ ] pluginval still passes
- [ ] All previous tests still pass
- [ ] New oversampling tests pass
- [ ] CPU usage reasonable with 2× (check with multiple instances)

### Listening
- [ ] Less aliasing on bright, driven material (compare with/without)
- [ ] No tonal change from oversampling itself
- [ ] No clicks or artifacts at block boundaries
- [ ] Offline bounces sound cleaner than real-time (4× vs 2×)

---

## Testing Checklist

```bash
# 1. Verify juce_dsp module is included
# Open GRAIN.jucer → check modules

# 2. Build
xcodebuild -project Builds/MacOSX/GRAIN.xcodeproj \
  -scheme "GRAIN - VST3" -configuration Debug build

# 3. Run pluginval
pluginval --validate ~/Library/Audio/Plug-Ins/VST3/GRAIN.vst3

# 4. Check unit tests (console output)

# 5. Manual listening test
# - Load plugin on bright synth
# - Set drive high (80%), mix 100%
# - Listen for: reduced harsh aliasing artifacts
# - Bounce offline: should sound slightly cleaner than real-time
```

---

## Technical Notes

### Dry Signal Copy

The dry signal must be copied BEFORE upsampling. Mix operates at original sample rate with the original dry signal. This ensures:
- Mix at 0% = exact original signal
- No aliasing in the dry path
- Less CPU (mix/gain don't need oversampling)

### Memory Allocation

`dryBuffer.makeCopyOf(buffer)` allocates memory, which is not ideal for real-time. A better approach for production:

```cpp
// In PluginProcessor.h
juce::AudioBuffer<float> dryBuffer;

// In prepareToPlay()
dryBuffer.setSize(getTotalNumInputChannels(), samplesPerBlock);

// In processBlock()
for (int ch = 0; ch < buffer.getNumChannels(); ++ch)
    dryBuffer.copyFrom(ch, 0, buffer, ch, 0, buffer.getNumSamples());
```

Pre-allocate in `prepareToPlay()` to avoid real-time allocation.

### Filter Type Choice

`filterHalfBandPolyphaseIIR` is chosen because:
- Lowest latency of JUCE's options
- Good quality for moderate oversampling (2×-4×)
- Minimal phase distortion

Alternative: `filterHalfBandFIREquiripple` — linear phase but higher latency.

### ScopedNoDenormals

Always include at the top of processBlock:
```cpp
juce::ScopedNoDenormals noDenormals;
```
Prevents CPU spikes from denormalized floating-point numbers (very small values near zero that are expensive to process).

---

## Out of Scope (future tasks)

- Standalone app (Task 008)
- User-selectable oversampling factor
- Minimum-phase vs linear-phase filter option
- Latency compensation for mix (not needed — latency is tiny)
