# Task 005: Warmth Control (Even/Odd Harmonic Balance)

## Objective

Implement a very subtle control that adjusts the balance between even and odd harmonics generated by the saturation stages. This is an internal "character" control — its effect should be cumulative and intentionally difficult to identify in direct A/B comparisons.

```
... → Waveshaper → [Warmth] → Focus → ...
```

---

## Prerequisites

- Task 004 completed (Dynamic Bias working)

---

## Design Rationale

### What Is Warmth?

The waveshaper (tanh) produces mainly **odd harmonics** (3rd, 5th, 7th...).
The dynamic bias promotes **even harmonics** (2nd, 4th, 6th...).

The Warmth control subtly shifts emphasis between these two families:

| Warmth | Character | Harmonics emphasized |
|--------|-----------|---------------------|
| 0% (cold) | Brighter, more edge | Odd dominant |
| 50% (neutral) | Balanced | Even + odd balanced |
| 100% (warm) | Softer, rounder | Even dominant |

### Why "Very Subtle"?

From the PRD:
> "Warmth: small control to steer harmonic flavor. Its effect is cumulative and intentionally difficult to identify in direct A/B comparisons."

This is NOT an EQ or tone control. It shapes the harmonic content generated by the saturation, not the frequency balance.

---

## Architecture

### Approach: Half-Wave Rectification Blend

The simplest approach to emphasize even vs odd harmonics:

- **Even harmonics** correlate with the asymmetric (rectified) component of the signal
- **Odd harmonics** correlate with the symmetric component

By blending between the original processed signal and a slightly asymmetric version, we can steer the harmonic balance.

### Pure Function (in `Source/DSP/GrainDSP.h`)

```cpp
namespace GrainDSP
{
    namespace Constants
    {
        // Existing constants...
        constexpr float kRMSAttackMs = 100.0f;
        constexpr float kRMSReleaseMs = 300.0f;
        
        // Warmth: maximum effect depth
        constexpr float kWarmthDepth = 0.1f;  // Very subtle (10% max)
    }

    // Warmth: subtle even/odd harmonic balance
    // input: signal after waveshaper
    // warmth: 0.0 = neutral, 1.0 = maximum warmth (more even harmonics)
    // prevSample: previous sample for simple difference calculation
    //
    // Returns: harmonically shaped signal
    inline float applyWarmth(float input, float warmth, float prevSample)
    {
        // Symmetric component (preserves odd harmonics)
        // Approximated by the signal itself
        float symmetric = input;
        
        // Asymmetric component (promotes even harmonics)
        // Simple approach: blend in a subtle half-wave bias
        float asymmetric = input * std::abs(input);
        
        // Blend based on warmth parameter
        float depth = warmth * Constants::kWarmthDepth;
        
        return symmetric + depth * (asymmetric - symmetric);
    }
    
    // Stateless version (no prevSample needed for this approach)
    // If we need a stateful version later, we can add it
}
```

### Alternative Approach: Simple Low-Pass Tilt

A complementary approach that doesn't require previous sample state:

```cpp
// Even simpler: warmth as very gentle spectral tilt
// Warm = slightly less high-frequency harmonic content
inline float applyWarmthTilt(float input, float warmth, float prevSample)
{
    // One-pole low-pass: warmer = more smoothing of harsh harmonics
    float depth = warmth * Constants::kWarmthDepth;
    
    // Gentle interpolation between current and previous sample
    return input * (1.0f - depth) + prevSample * depth;
}
```

### Choosing the Approach

| Method | Effect | Statefulness |
|--------|--------|-------------|
| **Half-wave blend** | Shifts harmonic balance directly | Stateless |
| **Low-pass tilt** | Reduces high-frequency harmonics | Needs prevSample |

**Recommendation:** Half-wave blend — more aligned with "even/odd balance" concept from PRD, and stateless (easier to test).

---

## Integration in processBlock

```cpp
void processBlock(juce::AudioBuffer<float>& buffer, ...)
{
    // Update targets at block start
    driveSmoothed.setTargetValue(*driveParam);
    biasSmoothed.setTargetValue(*biasParam);
    warmthSmoothed.setTargetValue(*warmthParam);  // NEW
    
    bool bypass = *bypassParam > 0.5f;
    float targetMix = bypass ? 0.0f : static_cast<float>(*mixParam);
    mixSmoothed.setTargetValue(targetMix);
    gainSmoothed.setTargetValue(juce::Decibels::decibelsToGain(*outputParam));

    for (int channel = 0; channel < buffer.getNumChannels(); ++channel)
    {
        auto* channelData = buffer.getWritePointer(channel);
        
        for (int sample = 0; sample < buffer.getNumSamples(); ++sample)
        {
            float drive = driveSmoothed.getNextValue();
            float biasAmount = biasSmoothed.getNextValue();
            float warmth = warmthSmoothed.getNextValue();  // NEW
            float mix = mixSmoothed.getNextValue();
            float gain = gainSmoothed.getNextValue();
            
            float dry = channelData[sample];
            
            // RMS detection (linked stereo)
            float rmsLevel = rmsDetector.process(dry);
            
            // Dynamic bias
            float biased = GrainDSP::applyDynamicBias(dry, rmsLevel, biasAmount);
            
            // Waveshaper
            float shaped = GrainDSP::applyWaveshaper(biased, drive);
            
            // Warmth (after waveshaper, before mix)
            float warmed = GrainDSP::applyWarmth(shaped, warmth, prevSample[channel]);
            prevSample[channel] = shaped;  // Store for next iteration
            
            // Mix + gain
            float mixed = GrainDSP::applyMix(dry, warmed, mix);
            channelData[sample] = GrainDSP::applyGain(mixed, gain);
        }
    }
}
```

**Note:** `prevSample` is only needed if using the low-pass tilt approach. The half-wave blend is stateless.

---

## New Parameter

Add to `AudioProcessorValueTreeState`:

| ID | Name | Range | Default | Notes |
|----|------|-------|---------|-------|
| `warmth` | Warmth | 0.0 – 1.0 | 0.0 | 0 = neutral, 1 = maximum warmth |

```cpp
params.push_back(std::make_unique<juce::AudioParameterFloat>(
    "warmth", "Warmth",
    juce::NormalisableRange<float>(0.0f, 1.0f, 0.01f),
    0.0f  // Neutral by default
));
```

---

## Parameter Smoothing

```cpp
// In PluginProcessor.h
juce::SmoothedValue<float> warmthSmoothed;

// In prepareToPlay()
warmthSmoothed.reset(sampleRate, 0.02);  // 20ms smoothing
```

---

## Unit Tests

Add to `Source/Tests/DSPTests.cpp`:

```cpp
void runWarmthTests()
{
    beginTest("Warmth: zero warmth returns input unchanged");
    {
        float input = 0.5f;
        float result = GrainDSP::applyWarmth(input, 0.0f, 0.0f);
        expectWithinAbsoluteError(result, input, TestConstants::TOLERANCE);
    }

    beginTest("Warmth: zero input returns zero");
    {
        float result = GrainDSP::applyWarmth(0.0f, 1.0f, 0.0f);
        expectWithinAbsoluteError(result, 0.0f, TestConstants::TOLERANCE);
    }

    beginTest("Warmth: effect is subtle (bounded)");
    {
        float input = 0.5f;
        float result = GrainDSP::applyWarmth(input, 1.0f, 0.0f);
        
        // Maximum deviation should be within kWarmthDepth (10%)
        float deviation = std::abs(result - input);
        expect(deviation < std::abs(input) * 0.15f);  // Allow some margin
    }

    beginTest("Warmth: positive input shifts toward asymmetry");
    {
        float input = 0.5f;
        float noWarmth = GrainDSP::applyWarmth(input, 0.0f, 0.0f);
        float fullWarmth = GrainDSP::applyWarmth(input, 1.0f, 0.0f);
        
        // With warmth, signal should be different from without
        expect(std::abs(fullWarmth - noWarmth) > TestConstants::TOLERANCE);
    }

    beginTest("Warmth: asymmetric effect on positive vs negative input");
    {
        float warmth = 1.0f;
        
        float resultPos = GrainDSP::applyWarmth(0.5f, warmth, 0.0f);
        float resultNeg = GrainDSP::applyWarmth(-0.5f, warmth, 0.0f);
        
        // The asymmetric component (input * |input|) differs for +/-
        // Positive: 0.5 * 0.5 = 0.25 (positive contribution)
        // Negative: -0.5 * 0.5 = -0.25 (negative contribution)
        // So |resultPos| and |resultNeg| should differ
        float deviationPos = std::abs(resultPos - 0.5f);
        float deviationNeg = std::abs(resultNeg - (-0.5f));
        
        // Both should show an effect
        expect(deviationPos > TestConstants::TOLERANCE);
        expect(deviationNeg > TestConstants::TOLERANCE);
    }

    beginTest("Warmth: continuous across warmth range");
    {
        float input = 0.5f;
        float prev = GrainDSP::applyWarmth(input, 0.0f, 0.0f);
        
        // Sweep warmth 0 → 1 in steps, no jumps
        for (float w = 0.1f; w <= 1.0f; w += 0.1f)
        {
            float current = GrainDSP::applyWarmth(input, w, 0.0f);
            float delta = std::abs(current - prev);
            
            // No discontinuity (delta should be small between 0.1 steps)
            expect(delta < 0.05f);
            prev = current;
        }
    }

    beginTest("Warmth: buffer stability with constant input");
    {
        float warmth = 0.7f;
        float input = 0.5f;
        
        // Process buffer - all outputs should be identical (stateless function)
        float expected = GrainDSP::applyWarmth(input, warmth, 0.0f);
        
        for (int i = 0; i < TestConstants::BUFFER_SIZE; ++i)
        {
            float result = GrainDSP::applyWarmth(input, warmth, 0.0f);
            expectWithinAbsoluteError(result, expected, TestConstants::TOLERANCE);
        }
    }
}
```

Don't forget to call `runWarmthTests()` from `runTest()`.

---

## Files to Create/Modify

| File | Action |
|------|--------|
| `Source/DSP/GrainDSP.h` | Add `applyWarmth` function + `kWarmthDepth` constant |
| `Source/PluginProcessor.h` | Add warmth parameter, smoothing |
| `Source/PluginProcessor.cpp` | Integrate warmth in processBlock |
| `Source/Tests/DSPTests.cpp` | Add warmth tests |

---

## Signal Flow After This Task

```
Input → RMS Detector → envelope
   ↓                      ↓
   └──→ Dynamic Bias ←────┘
            ↓
       Waveshaper (tanh)
            ↓
         Warmth          ← NEW
            ↓
          Mix
            ↓
          Gain
            ↓
         Output
```

---

## Acceptance Criteria

### Functional
- [ ] Warmth compiles without errors
- [ ] Warmth = 0 produces unchanged signal
- [ ] Warmth = 1 produces subtle change only
- [ ] Effect is continuous (no jumps across range)
- [ ] Asymmetric behavior (different effect on positive vs negative)

### Quality
- [ ] pluginval still passes
- [ ] All previous tests still pass
- [ ] New warmth tests pass

### Listening
- [ ] Warmth = 0: same as Task 004
- [ ] Warmth = 50%: barely perceptible difference
- [ ] Warmth = 100%: subtle but present, "rounder" character
- [ ] A/B comparison: difficult to identify the change (by design)
- [ ] No artifacts on sustained material

---

## Testing Checklist

```bash
# 1. Build
xcodebuild -project Builds/MacOSX/GRAIN.xcodeproj \
  -scheme "GRAIN - VST3" -configuration Debug build

# 2. Run pluginval
pluginval --validate ~/Library/Audio/Plug-Ins/VST3/GRAIN.vst3

# 3. Check unit tests (console output)

# 4. Manual listening test
# - Load plugin on mix bus
# - Set mix = 100%, drive = 50%, bias = 30%
# - Sweep warmth 0% → 100%
# - Listen for: very subtle tonal shift
# - Verify: effect is almost imperceptible in A/B
```

---

## Technical Notes

### kWarmthDepth = 0.1f

This limits the maximum effect to 10% of the signal. The rationale:

| kWarmthDepth | Effect at warmth=1.0 |
|--------------|---------------------|
| 0.05 | Almost inaudible |
| **0.1** | Subtle, cumulative |
| 0.2 | Noticeable in A/B |
| 0.5 | Too strong for GRAIN's philosophy |

May need adjustment after listening tests. The constant is in `GrainDSP::Constants::kWarmthDepth`.

### Half-Wave Blend Math

```
output = input + depth * (input * |input| - input)
       = input * (1 - depth) + depth * input * |input|
```

For positive input (0.5):
```
output = 0.5 * (1 - 0.1) + 0.1 * 0.5 * 0.5 = 0.45 + 0.025 = 0.475
```

For negative input (-0.5):
```
output = -0.5 * (1 - 0.1) + 0.1 * (-0.5) * 0.5 = -0.45 - 0.025 = -0.475
```

This creates asymmetry: positive peaks are compressed slightly less than negative peaks, promoting even harmonics.

---

## Out of Scope (future tasks)

- Focus control (Task 006) — spectral emphasis
- Combining warmth with focus for tonal shaping
- User-adjustable warmth depth
